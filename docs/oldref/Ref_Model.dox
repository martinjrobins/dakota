namespace Dakota {

/** \page ModelCommands Model Commands

\htmlonly
<b>Model Commands Table of Contents</b>
<ul>
<li> <a href="ModelCommands.html#ModelDescr">Model Description</a>
<li> <a href="ModelCommands.html#ModelSpec">Model Specification</a>
<li> <a href="ModelCommands.html#ModelIndControl">Model Independent Controls</a>
<li> <a href="ModelCommands.html#ModelSingle">Single Model Controls</a>
<li> <a href="ModelCommands.html#ModelSurrogate">Surrogate Model Controls</a>
  <ul>
  <li> <a href="ModelCommands.html#ModelSurrG">Global approximations</a>
  <li> <a href="ModelCommands.html#ModelSurrMP">Multipoint approximations</a>
  <li> <a href="ModelCommands.html#ModelSurrL">Local approximations</a>
  <li> <a href="ModelCommands.html#ModelSurrH">Hierarchical approximations</a>
  </ul>
<li> <a href="ModelCommands.html#ModelNested">Nested Model Controls</a>
</ul>
\endhtmlonly


\section ModelDescr Model Description


A %Dakota model specifies how variables are mapped into a set of
responses in support of an iterative method and the model
specification in an input file dictates the components to be used in
constructing a particular model instance. This specification selects a
Model from the model hierarchy, which includes SingleModel,
DataFitSurrModel, HierarchSurrModel, and NestedModel derived classes.
Depending on the type of derived model, different sub-specifications
are needed to construct different components of the model.

Several examples follow. The first example shows a minimal
specification for a single model, which is the default model when no
models are specified by the user.
\verbatim
model,
	single
\endverbatim
This example does not provide any pointer strings and therefore relies
on the default behavior of constructing the model with the last
variables, interface, and responses specifications parsed.

The next example displays a surrogate model specification which
selects a quadratic polynomial from among the global approximation
methods.  It uses a pointer to a design of experiments method for
generating the data needed for building the global approximation, reuses
any old data available for the current approximation region, and
employs the first-order multiplicative approach to correcting the
approximation each time correction is requested.

\verbatim
model,
	id_model = 'M1'
	variables_pointer = 'V1'
	responses_pointer = 'R1'
	surrogate global
	  polynomial quadratic
	  dace_method_pointer = 'DACE'
	  reuse_samples region
	  correction multiplicative first_order
\endverbatim
This example demonstrates the use of identifiers and pointers.  It
provides the optional model independent specifications for model
identifier, variables pointer, and responses pointer (see \ref
ModelIndControl) as well as model dependent specifications for 
global surrogates (see \ref ModelSurrG).

Finally, an advanced nested model example would be
\verbatim
model,
	id_model = 'M1'
	variables_pointer = 'V1'
	responses_pointer = 'R1'
	nested
	  optional_interface_pointer = 'OI1'
	    optional_interface_responses_pointer = 'OIR1'
	  sub_method_pointer = 'SM1'
	    primary_variable_mapping   = ''  ''  'X'     'Y'
	    secondary_variable_mapping = ''  ''  'mean'  'mean'
	    primary_response_mapping   = 1. 0. 0. 0. 0. 0. 0. 0. 0.
	    secondary_response_mapping = 0. 0. 0. 1. 3. 0. 0. 0. 0.
					 0. 0. 0. 0. 0. 0. 1. 3. 0.
\endverbatim 
This example also supplies model independent controls for model
identifier, variables pointer, and responses pointer (see \ref
ModelIndControl), and supplies model dependent controls for specifying
details of the nested mapping (see \ref ModelNested).


\section ModelSpec Model Specification


As alluded to in the examples above, the model specification 
has the following structure:
\verbatim
model,
	<model independent controls>
	<model selection>
	  <model dependent controls>
\endverbatim

The <tt>\<model independent controls\></tt> are those controls which
are valid for all models. Referring to dakota.input.summary, these
controls are defined externally from and prior to the model selection
blocks. The model selection blocks are all required group
specifications separated by logical OR's, where the model selection
must be \c single OR \c surrogate OR \c nested. If a \c surrogate
model is specified, a secondary selection must be made for its type:
\c global, \c multipoint, \c local, or \c hierarchical.  The
<tt>\<model dependent controls\></tt> are those controls which are
only meaningful for a specific model.  These controls are defined
within each model selection block. Defaults for model independent and
model dependent controls are defined in DataModel.  The following
sections provide additional detail on the model independent controls
followed by the model selections and their corresponding model
dependent controls.


\section ModelIndControl Model Independent Controls


The model independent controls include a model identifier string,
pointers to variables and responses specifications, and a model type
specification.  The model identifier string is supplied with \c
id_model and is used to provide a unique identifier string for use
within method specifications (refer to \c model_pointer in \ref
MethodIndControl).

The type of model can be \c single, \c nested, or \c surrogate.  Each
of these model specifications supports \c variables_pointer and \c
responses_pointer strings for identifying the variables and responses
specifications used in constructing the model (by cross-referencing
with \c id_variables and \c id_responses strings from particular
variables and responses keyword specifications).  These pointers are
valid for each model type since each model contains a set of variables
that is mapped into a set of responses -- only the specifics of the
mapping differ.  Additional pointers are used for each model type for
constructing the components of the variable to response mapping.  As an
environment specification identifies a top-level method and a method
specification identifies a model, a model specification identifies
variables, responses, and (for some types) interface specifications.
This top-down flow specifies all of the object interrelationships.

For each of these pointer specifications, if a pointer string is
specified and no corresponding id string is available, %Dakota will
exit with an error message. If the pointer is optional and no pointer
string is specified, then the last specification parsed will be
used. It is appropriate to omit optional cross-referencing whenever
the relationships are unambiguous due to the presence of only one
specification.

The hierarchical tagging (\c hierarchical_tagging) option is useful
for studies involving multiple models with a nested or hierarchical
relationship.  For example a nested model has a sub-method, which
itself likely operates on a sub-model, or a hierarchical approximation
involves coordination of low and high fidelity models.  Specifying \c
hierarchical_tagging will yield function evaluation identifiers
("tags") composed of the evaluation IDs of the models involved, e.g.,
outermodel.innermodel.interfaceid = 4.9.2.  This communicates the
outer contexts to the analysis driver when performing a function
evaluation.

Table \ref T6d1 "6.1" provides the specification detail for the model
independent controls involving identifiers, model type controls, and
pointers.

\anchor T6d1 
<table>
<caption align = "top">
\htmlonly
Table 6.1
\endhtmlonly
Specification detail for the model independent controls: identifiers, 
model types, and pointers
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>%Model set identifier
<td>\c id_model
<td>string
<td>Optional
<td>method use of last model parsed
<tr>
<td>%Model type
<td>\c single | \c surrogate | \c nested
<td>none
<td>Required group
<td>N/A (\c single if no model specification)
<tr>
<td>%Variables set pointer
<td>\c variables_pointer
<td>string
<td>Optional
<td>model use of last variables parsed
<tr>
<td>Responses set pointer
<td>\c responses_pointer
<td>string
<td>Optional
<td>model use of last responses parsed
<tr>
<td>Hierarchical evaluation tags
<td>\c hierarchical_tagging
<td>none
<td>Optional
<td>no hierarchical tagging
</table>


\section ModelSingle Single Model Controls


In the \c single model case, a single interface is used to map the
variables into responses.  The optional \c interface_pointer
specification identifies this interface by cross-referencing with the
\c id_interface string input from a particular interface keyword
specification.

Table \ref T6d2 "6.2" provides the specification detail for single
models.

\anchor T6d2 
<table>
<caption align = "top">
\htmlonly
Table 6.2
\endhtmlonly
Specification detail for single models
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>%Interface set pointer
<td>\c interface_pointer
<td>string
<td>Optional
<td>model use of last interface parsed
</table>


\section ModelSurrogate Surrogate Model Controls


In the \c surrogate model case, the specification first allows a
mixture of surrogate and actual response mappings through the use of
the optional \c id_surrogates specification.  This identifies the
subset of the response functions by number that are to be approximated
(the default is all functions).  The valid response function
identifiers range from 1 through the total number of response
functions (see \ref RespFn).  Next, the specification selects a
global, multipoint, local, or hierarchical approximation.  Table 
\ref T6d3 "6.3" provides the specification detail for surrogate models.

\anchor T6d3 
<table>
<caption align = "top">
\htmlonly
Table 6.3
\endhtmlonly
Specification detail for the surrogate models
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>Surrogate response ids
<td>\c id_surrogates
<td>list of integers
<td>Optional
<td>All response functions are approximated
<tr>
<td>Surrogate type selection
<td>\c global | \c multipoint | \c local | \c hierarchical
<td>none
<td>Required group
<td>N/A
</table>

Each of these surrogate types provides an approximate representation
of a "truth" model which is used to perform the parameter to response
mappings. This approximation is built and updated using data from the
truth model.  This data is generated in some cases using a design of
experiments iterator applied to the truth model (global approximations
with a \c dace_method_pointer).  In other cases, truth model data from
a single point (local, hierarchical approximations), from a few
previously evaluated points (multipoint approximations), or from the
restart database (global approximations with \c reuse_samples) can be
used.  Surrogate models are used extensively in the surrogate-based
optimization and least squares methods (see SurrBasedMinimizer and its
derived classes and \ref MethodSBL and \ref MethodSBG), in which the
goals are to reduce expense by minimizing the number of truth function
evaluations and to smooth out noisy data with a global data fit.
However, the use of surrogate models is not restricted to optimization
techniques; uncertainty quantification and optimization under
uncertainty methods are other primary users.

The following sections present the \c global, \c multipoint, \c local,
and \c hierarchical specification groups in further detail.


\subsection ModelSurrG Global approximations

The global surrogate model requires specification of one of the
following approximation types: \c polynomial, \c gaussian_process, \c
neural_network, \c mars, \c moving_least_squares, <!-- \c
orthogonal_polynomial, --> or \c radial_basis.  These specifications
will create a polynomial, a Gaussian process (Kriging interpolation),
layered perceptron artificial neural network approximation,
multivariate adaptive regression spline, moving least squares, <!-- an
orthogonal polynomial (Hermite, Legendre, Laguerre, Jacobi, and/or
generalized Laguerre) approximation, --> or radial basis function
approximation, respectively.  All these approximations are implemented
in \ref Giunta2006 "SurfPack" except an alternate Gaussian process
model, which is implemented directly in %Dakota.

In the polynomial case, the order of the polynomial (linear,
quadratic, or cubic) must be specified. 

%Dakota has two Gaussian process (GP) or Kriging models, one that
resides in %Dakota proper and the other in %Dakota's Surfpack
subpackage.  Choice of the GP implmentation is made by specifying \c
gaussian_process (alternately \c kriging) followed by either \c dakota
or \c surfpack.  Historically these models were drastically different,
but in %Dakota 5.1, they became quite similar.  They now differ in that
the Surfpack GP has a richer set of features/options and tends to be
more accurate than the %Dakota version.  Due to how the Surfpack GP
handles ill-conditioned correlation matrices (which significantly
contributes to its greater accuracy), the \c Surfpack GP can be a
factor of two or three slower than %Dakota's.  As of %Dakota 5.2, the
Surfpack implementation is the default in all contexts except Bayesian
calibration.  The %Dakota GP is provided for continuity, but may be
deprecated in the future.
For more details on the Surfpack GP, see [\ref Dalbey2013 "Dalbey, 2013"].

The trend function of both GP models is selected using the \c trend
keyword, with options \c constant, \c linear, or \c reduced_quadratic
(default).  The Surfpack GP has the additional option of (a full) \c
quadratic.  The \c reduced_quadratic trend function includes the main
effects, but not mixed/interaction terms.  <!-- NOTE: prior to %Dakota 5.1,
\c reduced_quadratic was selected for the %Dakota GP via the \c
quadratic option. -->

The %Dakota GP always determines its correlation parameters via maximum
likelihood estimate (MLE) using a global optimization procedure.
Ill-conditioning induced by poorly spaced sample points is a common
challenge in the construction of Gaussian process models.  %Dakota's GP
deals with ill-conditioning in two ways.  First, when it encounters a
non-invertible correlation matrix it iteratively increases the size of
a "nugget," but in such cases the resulting approximation smooths
rather than interpolates the data. Second, it has a \c point_selection
option (default off) that uses a greedy algorithm to select a
well-spaced subset of points prior to the construction of the GP.  In
this case, the GP will only interpolate the selected
subset. Typically, one should not need point selection in trust-region
methods because a small number of points are used to develop a
surrogate within each trust region.  Point selection is most
beneficial when constructing with a large number of points, typically
more than order one hundred, though this depends on the number of
variables and spacing of the sample points.

By default, the Surfpack GP also selects its correlation parameters
using a global optimizer, but its search is concentrated in a smaller
feasible region of correlation parameters. However, one may force the
Surfpack GP to use a different search algorithm by specifying \c
optimization_method followed by any of \c 'global', \c 'local', \c
'sampling', or \c 'none'.  The none option and starting location of
the local search default to the center of the small feasible region of
correlation lengths.  However, one may also directly specify \c
correlation_lengths as a list of N real numbers where N is the number
of input dimensions.  As of %Dakota 5.2, the Surfpack GP handles
ill-conditioning by selecting the subset of points that tightly meets
a constraint on the condition number and provides the maximum amount
of useful information for the correlation lengths chosen by MLE. For
each set of correlation lengths examined during the MLE optimization,
the optimal subset of points for those correlation lengths is used.
The subset of points used to build the Surfpack GP is the one
associated with the most likely set of correlation lengths.  This
differs from the \c point_selection option of the %Dakota GP which
initially chooses a well-spaced subset of points and finds the
correlation parameters that are most likely for that one subset.  It
is similar to the %Dakota GP's point selection in that the Surfpack GP
will only interpolate the selected subset of points.

Note that typically, the Surfpack GP handles ill-conditioning and 
does not use a nugget.  If the user wishes to specify a nugget, 
there are two approaches.  The user can specify the value 
of a nugget with \c nugget.  In this case, the nugget will be 
the value defined by the user.  The other approach is to have 
Surfpack find the optimal value of the nugget.  This 
is specified by \c find_nugget.  There are two options for \c find_nugget. 
If the user specifies \c find_nugget = 1, kriging will assume that the 
reciprocal condition number of the correlation matrix R, rcondR, is zero and 
calculate the nugget needed to make the worst case of R not 
ill-conditioned.  If \c find_nugget = 2, it means kriging will calculate rcondR, 
which requires a Cholesky factorization. If rcondR indicates that R is not 
ill-conditioned, then kriging uses the Cholesky factorization. 
Otherwise, if rcondR says R is ill conditioned, then kriging will 
calculate the nugget needed to make the worst case of R not ill conditioned. 
\c find_nugget = 1 or 2 are similar, the second option just takes more 
computation (the initial Cholesky factorization) for larger problems.

The \c use_derivatives keyword will cause the Surfpack GP to be
constructed from a combination of function value and gradient
information (if available).  This is only beneficial when a function
value plus a gradient can be computed at a computational cost
comparable to a function value only.  This rules out gradients
computed by finite differences (which also tend to be insufficiently
accurate).  However, the accurate and inexpensive derivatives
calculated by analytical, automatic differentiation, or continuous
adjoint techniques can be cost effective and beneficial.  <!--
provided that they are not infinite or nearly so.--> Although a
function value plus gradient can be often be obtained more cheaply
than two function value-only evaluations, each scalar derivative
equation costs as much as a scalar function value equation during the
construction of the emulator.  Since the cost to build a GP is cubic
in the number of equations, the cost to build a gradient-enhanced
GP/Kriging model will be roughly (N+1)^3 times greater than one that
is not gradient-enhanced, where N is the number of input dimensions.
Also, a poorly spaced sample design has a greater adverse affect on
the conditioning of the correlation matrix when derivative information
is included. This can result in significantly more points being
discarded and hence providing little benefit to the derivative
enhanced GP/Kriging model's accuracy. For more details on 
the use of derivatives in the kriging model, see [\ref Dalbey2013 "Dalbey, 2013"].

<!-- TODO: document MARS, ANN, and RBF controls -->
Tables \ref T6d4 "6.4" and \ref T6d5 "6.5" summarize the global 
approximation selection specifications.

\anchor T6d4
<table>
<caption align = "top">
\htmlonly
Table 6.4
\endhtmlonly
Specification detail for global approximations: global 
approximation type, Part I
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>Global approximations 
<td>\c global
<td>none
<td>Required group (1 of 4 selections)
<td>N/A
<tr>
<td>Polynomial
<td>\c polynomial
<td>\c linear | \c quadratic | \c cubic
<td>Required group (1 of 7 selections)
<td>N/A
<tr>
<td>%Dakota Gaussian process
<td>\c gaussian_process
<td>dakota
<td>Required (1 of 7 selections)
<td>N/A
<tr>
<td>GP trend function
<td>\c trend
<td>\c constant | \c linear | \c reduced_quadratic
<td>Optional
<td>reduced_quadratic trend
<tr>
<td>GP point selection
<td>\c point_selection
<td>none
<td>Optional
<td>no point selection
<tr>
<td>Surfpack Gaussian process (Kriging)
<td>\c gaussian_process
<td>surfpack
<td>Required group (1 of 7 selections)
<td>N/A
<tr>
<td>Surfpack GP trend function
<td>\c trend
<td>\c constant | \c linear | \c reduced_quadratic | \c quadratic
<td>Optional
<td>\c reduced_quadratic trend
<tr>
<td>Surfpack GP correlation lengths
<td>\c correlation_lengths
<td>list of reals
<td>Optional for none/local
<td>internally computed correlation_lengths
<tr>
<td>Surfpack GP optimization method
<td>\c optimization_method
<td>\c 'global' | \c 'local' | \c 'sampling' | \c 'none'
<td>Optional 
<td>global 
<tr>
<td>Surfpack GP maximum trials
<td>\c max_trials
<td>integer
<td>Optional
<td>
<tr>
<td>Surfpack user-specified nugget 
<td>\c nugget
<td>real
<td>Optional
<td>None
<tr>
<td>Surfpack finds the optimal nugget 
<td>\c find_nugget
<td>integer
<td>Optional (values = 1 or 2)
<td>None
<tr>
<td>Surfpack GP gradient enhancement
<td>\c use_derivatives
<td>none
<td>Optional
<td>no gradient enhancement
</table>

\anchor T6d5
<table>
<caption align = "top">
\htmlonly
Table 6.5
\endhtmlonly
Specification detail for global approximations: global 
approximation type, Part II
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>Artificial neural network
<td>\c neural_network
<td>none
<td>Required (1 of 7 selections)
<td>N/A
<tr>
<td>ANN number nodes
<td>\c nodes
<td>integer
<td>Optional
<td>
<tr>
<td>ANN range
<td>\c range
<td>real
<td>Optional
<td>
<tr>
<td>ANN random weight
<td>\c random_weight
<td>integer
<td>Optional
<td>
<tr>
<td>Multivariate adaptive regression splines
<td>\c mars
<td>none
<td>Required (1 of 7 selections)
<td>N/A
<tr>
<td>MARS maximum bases
<td>\c max_bases
<td>integer
<td>Optional
<td>
<tr>
<td>MARS interpolation
<td>\c interpolation
<td>\c linear | \c cubic
<td>Optional
<td>
<tr>
<td>Moving least squares
<td>\c moving_least_squares
<td>none
<td>Required (1 of 7 selections)
<td>N/A
<tr>
<td>MLS polynomial order
<td>\c poly_order
<td>integer
<td>Optional
<td>
<tr>
<td>MLS weight function
<td>\c weight_function
<td>integer
<td>Optional
<td>
<!--
<tr>
<td>Orthogonal polynomial
<td>\c orthogonal_polynomial
<td>none
<td>Required (1 of 7 selections)
<td>N/A
-->
<tr>
<td>Radial basis functions
<td>\c radial_basis_functions
<td>none
<td>Required group (1 of 7 selections)
<td>N/A
<tr>
<td>RBF number of bases
<td>\c bases
<td>integer
<td>Optional
<td>
<tr>
<td>RBF maximum points
<td>\c max_pts
<td>integer
<td>Optional
<td>
<tr>
<td>RBF minimum partitions
<td>\c min_partition
<td>integer
<td>Optional
<td>
<tr>
<td>RBF maximum subsets
<td>\c bases
<td>integer
<td>Optional
<td>
</table>

Table \ref T6d6 "6.6" summarizes the remaining (optional) global
approximation specifications, including controls for the number of
points requested to build the surrogate, the source of the points (\c
dace_method_pointer and \c reuse_samples), the use of derivative
information in constructions (\c use_derivatives), calculation of
fitness metrics, and the \c correction method.

The number of points used in building a global approximation is
determined by three point counts:

\li %Model points: Each global surrogate type has an associated
minimum reasonable and recommended number of build points, selected
via \c minimum_points and \c recommended_points (default),
respectively, within a global surrogate model specification.
Alternately an integer \c total_points may be specified to request a
specific number of points in each surrogate build (a lower bound of
minimum points is enforced).  This count, then, can be summarized as
%Model points = (minimum | recommended | max(minimum, total)).

\li Reused points: any samples available for reuse via the \c
reuse_samples keyword (described below) are always used to build.
This count defaults to zero.

\li %Iterator points: \c samples specified within the DACE method 
specification (identified via \c dace_method_pointer) always
provide a lower bound on the number of fresh DACE samples used to
build the surrogate.  This count defaults to zero.

The number of new points to be evaluated by the DACE method is defined
by New points = max(%Model points - Reused points, %Iterator points),
using the logic that the number of points needed is %Model points minus
Reused points, but respecting a lower bound DACE samples specification
when present.  The total number of points used in the surrogate build
is then New points + Reused points.  The DACE iterator will only be
invoked if it has new samples to perform, and if new samples are
required and no DACE iterator has been provided, an error will result.

The \c dace_method_pointer links to design of experiments iterator
used to generate truth model data for building a global data fit.  The
\c reuse_samples specification can be used to employ old data (either
from previous function evaluations performed in the run or from
function evaluations read from a restart database or text file) in the
building of new global approximations.  The default is no reuse of old
data (since this can induce directional bias), and the settings of \c
all, \c region, and \c import_points_file result in reuse of all
available data, reuse of all data available in the current trust
region, and reuse of all data from a specified text file,
respectively.  Both \c dace_method_pointer and \c reuse_samples are
optional specifications, which gives the user maximum flexibility in
using design of experiments data, restart/text file data, or both.  A
global surrogate may also export any approximation-based samples to a
separate file (note: these samples are also included in the standard
output stream for output level of \c verbose or higher), identified
using the \c export_points_file option. The tabular format employed
for both the import and export data files may be either \c annotated
or \c freeform, where the former includes a descriptive header and
evaluation counter and the latter only contains the input and output
data.

The \c use_derivatives flag specifies that any available derivative
information should be used in global approximation builds, for those
global surrogate types that support it (currently, polynomial
regression and the Surfpack GP). <!-- This capability is currently
supported in SurrBasedLocalMinimizer, Pecos::SurrogateDataPoint, \ref
Approximation::build "Approximation::build()", and \c global_kriging
models, but is not yet supported in any global approximation derived
class redefinitions of build(). -->

To assess the goodness of fit of a global surrogate, a variety of
diagnostic metrics are available for the following global
approximation methods: polynomial regressions, kriging, mars, moving
least squares, neural networks, and radial basis functions.  The
diagnostics are specified by the keyword \c metrics, followed by a
list of strings specifying the metrics to compute.  The diagnostic
metrics available are: \c sum_squared, \c mean_squared, \c
root_mean_squared, \c sum_abs, \c mean_abs, \c max_abs, and \c
rsquared. Most of these diagnostics refer to some operation on the
residuals (the difference between the surrogate model and the truth
model at the data points upon which the surrogate is built).  For
example, \c sum_squared refers to the sum of the squared residuals,
and \c mean_abs refers to the mean of the absolute value of the
residuals.  \c rsquared refers to the R-squared value typically used
in regression analysis (the proportion of the variability in the
response that can be accounted for by the surrogate model).  Care
should be taken when interpreting metrics, for example, errors may be
near zero for interpolatory models or rsquared may not be applicable
for non-polynomial models.

General k-fold or leave-one-out (PRESS) cross validation may be
performed by specifying \c cross_validation and/or \c press after the
list of metrics.  The cross-validation statistics will be calculated
for all metrics specified.  General cross validation may include
either \c folds, the number of folds into which to divide the build
data (between 2 and number of data points), or \c percent, the
fraction of data (between 0 and 0.5) to use in each fold.  These will
be adjusted as needed based on the number of available training
points.

In addition, metrics may be computed against a user-specified \c
challenge_points_file, containing variables and function values of
test data.  The requested metrics will be reported for the surrogate
evaluated at the specified variables versus the function values from
the challenge data file.  The imported points file may be in annotated
for free-form tabular format as described in the User's manual.

The \c correction specification specifies that the approximation will
be corrected to match truth data, either matching truth values in the
case of \c zeroth_order matching, matching truth values and gradients
in the case of \c first_order matching, or matching truth values,
gradients, and Hessians in the case of \c second_order matching.  For
\c additive and \c multiplicative corrections, the correction is local
in that the truth data is matched at a single point, typically the
center of the approximation region.  The \c additive correction adds a
scalar offset (\c zeroth_order), a linear function (\c first_order),
or a quadratic function (\c second_order) to the approximation to
match the truth data at the point, and the \c multiplicative
correction multiplies the approximation by a scalar (\c zeroth_order),
a linear function (\c first_order), or a quadratic function (\c
second_order) to match the truth data at the point.  The \c additive
\c first_order case is due to [\ref Lewis2000 "Lewis and Nash, 2000"]
and the \c multiplicative \c first_order case is commonly known as
beta correction [\ref Haftka1991 "Haftka, 1991"].  For the \c combined
correction, the use of both additive and multiplicative corrections
allows the satisfaction of an additional matching condition, typically
the truth function values at the previous correction point (e.g., the
center of the previous trust region).  The \c combined correction is
then a multipoint correction, as opposed to the local \c additive and
\c multiplicative corrections.  Each of these correction capabilities
is described in detail in [\ref Eldred2004a "Eldred et al., 2004a"].

\anchor T6d6
<table>
<caption align = "top">
\htmlonly
Table 6.6
\endhtmlonly
Specification detail for global approximations: build and correction controls
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>Number of build points
<td>\c total_points | \c minimum_points | \c recommended_points 
<td>integer | none | none
<td>Optional
<td>recommended_points
<tr>
<td>Design of experiments method pointer
<td>\c dace_method_pointer
<td>string
<td>Optional
<td>no design of experiments data
<tr>
<td>Sample reuse in global approximation
<td>\c reuse_samples
<td>\c all | \c region | \c none
<td>Optional group
<td>\c all if \c import_points_file defined, \c none otherwise
<tr>
<td>File import of samples for global approximation builds
<td>\c import_points_file
<td>string
<td>Optional
<td>no point import from a file
<tr>
<td>Import points file format
<td>\c annotated | \c freeform
<td>boolean
<td>Optional
<td>annotated
<tr>
<td>File export of global approximation-based sample results
<td>\c export_points_file
<td>string
<td>Optional
<td>no point export to a file
<tr>
<td>Export points file format
<td>\c annotated | \c freeform
<td>boolean
<td>Optional
<td>annotated
<tr>
<td>Use of derivative data in global approximation builds
<td>\c use_derivatives
<td>none
<td>Optional
<td>derivative data not used in global approximation builds
<tr>
<td>Compute surrogate diagnostics
<td>\c metrics
<td>1 or more of \c sum_squared, \c mean_squared, \c root_mean_squared, 
    \c sum_abs, \c mean_abs, \c max_abs, \c rsquared
<td>Optional
<td>No diagnostics
<tr>
<td>Perform cross validation
<td>\c cross_validation
<td>none
<td>Optional
<td>No cross validation
<tr>
<td>Number cross validation folds
<td>\c folds
<td>none
<td>Optional
<td>10
<tr>
<td>Percent points per CV fold
<td>\c percent
<td>none
<td>Optional
<td>0.1
<tr>
<td>Perform PRESS cross validation
<td>\c press
<td>none
<td>Optional
<td>No PRESS cross validation
<tr>
<td>Challenge file for surrogate metrics
<td>\c challenge_points_file
<td>string
<td>Optional
<td>no user challenge data
<tr>
<td>Challenge file in annotated format
<td>\c annotated 
<td>boolean
<td>Optional
<td>annotated
<tr>
<td>Challenge file in freeform format
<td>\c freeform
<td>boolean
<td>Optional
<td>annotated
<tr>
<td>Surrogate correction approach
<td>\c correction
<td>\c additive | \c multiplicative | \c combined; \c zeroth_order | \c first_order | \c second_order
<td>Optional group
<td>no surrogate correction
</table>


\subsection ModelSurrMP Multipoint approximations

Multipoint approximations use data from previous design points to
improve the accuracy of local approximations.  Currently, the
Two-point Adaptive Nonlinearity %Approximation (TANA-3) method of
[\ref Xu1998 "Xu and Grandhi, 1998"] is supported. This method
requires response value and gradient information from two points, and
uses a first-order Taylor series if only one point is available.  The
truth model to be used to generate the value/gradient data used in the
approximation is identified through the required \c
actual_model_pointer specification.  \ref T6d7 "Table 6.7" summarizes
the multipoint approximation specifications.

\anchor T6d7
<table>
<caption align = "top">
\htmlonly
Table 6.7
\endhtmlonly
Specification detail for multipoint approximations
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>Multipoint approximation
<td>\c multipoint
<td>none
<td>Required group (1 of 4 selections)
<td>N/A
<tr>
<td>Two-point adaptive nonlinear approximation 
<td>\c tana
<td>none
<td>Required
<td>N/A
<tr>
<td>Pointer to the truth model specification
<td>\c actual_model_pointer
<td>string
<td>Required
<td>N/A
</table>


\subsection ModelSurrL Local approximations

Local approximations use value, gradient, and possibly Hessian data
from a single point to form a series expansion for approximating data
in the vicinity of this point.  The currently available local
approximation is the \c taylor_series selection.  The order of the
Taylor series may be either first-order or second-order, which is
automatically determined from the gradient and Hessian specifications
in the responses specification (see \ref RespGrad and \ref RespHess)
for the truth model.
<!-- The first-order Taylor series expansion is known as the -->
<!-- "linear approximation" in the optimization literature.  Other local -->
<!-- approximations, such as the "reciprocal" and "conservative/convex" -->
<!-- approximations, may become available in the future. -->
The truth model to be used to generate the value/gradient/Hessian data
used in the series expansion is identified through the required \c
actual_model_pointer specification.  The use of a model pointer (as
opposed to an interface pointer) allows additional flexibility in
defining the approximation.  In particular, the derivative
specification for the truth model may differ from the derivative
specification for the approximation , and the truth model results
being approximated may involve a model recursion (e.g., the
values/gradients from a nested model).  \ref T6d8 "Table 6.8"
summarizes the local approximation interface specifications.

\anchor T6d8
<table>
<caption align = "top">
\htmlonly
Table 6.8
\endhtmlonly
Specification detail for local approximations
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>Local approximation
<td>\c local
<td>none
<td>Required group (1 of 4 selections)
<td>N/A
<tr>
<td>Taylor series local approximation 
<td>\c taylor_series
<td>none
<td>Required
<td>N/A
<tr>
<td>Pointer to the truth model specification
<td>\c actual_model_pointer
<td>string
<td>Required
<td>N/A
</table>


\subsection ModelSurrH Hierarchical approximations

Hierarchical approximations use corrected results from a low fidelity
model as an approximation to the results of a high fidelity "truth"
model.  These approximations are also known as model hierarchy,
multifidelity, variable fidelity, and variable complexity
approximations.  The required \c low_fidelity_model_pointer
specification points to the low fidelity model specification.  This
model is used to generate low fidelity responses which are then
corrected and returned to an iterator.  The required \c
high_fidelity_model_pointer specification points to the specification
for the high fidelity truth model.  This model is used only for
verifying low fidelity results and updating low fidelity corrections.
The \c correction specification specifies which correction technique
will be applied to the low fidelity results in order to match the high
fidelity results at one or more points.  In the hierarchical case (as
compared to the global case), the \c correction specification is
required, since the omission of a correction technique would
effectively eliminate the purpose of the high fidelity model.  If it
is desired to use a low fidelity model without corrections, then a
hierarchical approximation is not needed and a \c single model should
be used.  Refer to \ref ModelSurrG for additional information on
available correction approaches.  \ref T6d9 "Table 6.9" summarizes the
hierarchical approximation specifications.

\anchor T6d9
<table>
<caption align = "top">
\htmlonly
Table 6.9
\endhtmlonly
Specification detail for hierarchical approximations
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>Hierarchical approximation 
<td>\c hierarchical
<td>none
<td>Required group (1 of 4 selections)
<td>N/A
<tr>
<td>Pointer to the low fidelity model specification
<td>\c low_fidelity_model_pointer
<td>string
<td>Required
<td>N/A
<tr>
<td>Pointer to the high fidelity model specification
<td>\c high_fidelity_model_pointer
<td>string
<td>Required
<td>N/A
<tr>
<td>Surrogate correction approach
<td>\c correction
<td>\c additive | \c multiplicative | \c combined; \c zeroth_order | \c first_order | \c second_order
<td>Required group
<td>N/A
</table>


\section ModelNested Nested Model Controls

Instead of appealing directly to a primary interface, a nested model
maps parameters to responses by executing a sub-iterator for each
evaluation of the nested model; the sub-iterator in turn operates on a
sub-model.  The sub-iterator responses may be combined with non-nested
contributions from an optional interface specification.

In the \c nested model case, a \c sub_method_pointer must be provided
in order to specify the nested iterator, and \c
optional_interface_pointer and \c optional_interface_responses_pointer
provide an optional group specification for the optional interface
portion of nested models (where \c optional_interface_pointer points
to the interface specification and \c
optional_interface_responses_pointer points to a responses
specification describing the data to be returned by this interface).
This interface is used to provide non-nested data, which is then
combined with data from the nested iterator using the \c
primary_response_mapping and \c secondary_response_mapping inputs (see
mapping discussion below).

Table \ref T6d10 "6.10" provides the specification detail for nested
model pointers.

\anchor T6d10
<table>
<caption align = "top">
\htmlonly
Table 6.10
\endhtmlonly
Specification detail for nested models
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>%Optional interface set pointer
<td>\c optional_interface_pointer
<td>string
<td>Optional group
<td>no optional interface
<tr>
<td>Responses pointer for nested model optional interfaces
<td>\c optional_interface_responses_pointer
<td>string
<td>Optional
<td>reuse of top-level responses specification
<tr>
<td>Sub-method pointer for nested models
<td>\c sub_method_pointer
<td>string
<td>Required
<td>N/A
</table>

Nested models may employ mappings for both the variable inputs to the
sub-model and the response outputs from the sub-model.  In the former
case, the \c primary_variable_mapping and \c
secondary_variable_mapping specifications are used to map from the
active top-level variables into the sub-model variables, and in the
latter case, the \c primary_response_mapping and \c
secondary_response_mapping specifications are used to compute the
sub-model response contributions to the top-level responses.  

For the variable mappings, the primary and secondary specifications
provide lists of strings which are used to target specific sub-model
variables and their sub-parameters, respectively.  The primary strings
are matched to continuous or discrete variable labels such as \c
'cdv_1' (either user-supplied or default labels), and the secondary
strings are matched to either real or integer random variable
distribution parameters such as \c 'mean' or \c 'num_trials' (the form
of the uncertain distribution parameter keyword that is appropriate
for a single variable instance) or continuous or discrete design/state
variable sub-parameters such as \c 'lower_bound' or \c 'upper_bound'
(again, keyword form appropriate for a single variable instance).  No
coercion of types is supported, so real-valued top-level variables
should map to either real-valued sub-model variables or real-valued
sub-parameters and integer-valued top-level variables should map to
either integer-valued sub-model variables or integer-valued
sub-parameters.  As long as these real versus integer constraints are
satisfied, mappings are free to cross variable types (design, aleatory
uncertain, epistemic uncertain, state) and domain types (continuous,
discrete).  Both \c primary_variable_mapping and \c
secondary_variable_mapping specifications are optional, which is
designed to support the following three possibilities:

-# If both primary and secondary variable mappings are specified,
   then an active top-level variable value will be inserted into the
   identified sub-parameter (the secondary mapping) for the identified 
   sub-model variable (the primary mapping).
-# If a primary mapping is specified but a secondary mapping is not,
   then an active top-level variable value will be inserted into the
   identified sub-model variable value (the primary mapping).
-# If a primary mapping is not specified (corresponding secondary 
   mappings, if specified, are ignored), then an active top-level 
   variable value will be inserted into a corresponding sub-model 
   variable, based on matching of variable types (e.g., top-level 
   and sub-model variable specifications both allocate a set of \c 
   'continuous_design' variables which are active at the top level).  
   Multiple sub-model variable types may be updated in this manner, 
   provided that they are all active in the top-level variables.
   Since there is a direct variable correspondence for these default
   insertions, sub-model bounds and labels are also updated from the
   top-level bounds and labels in order to eliminate the need for
   redundant input file specifications.  Thus, it is typical for the
   sub-model variables specification to only contain the minimal
   required information, such as the number of variables, for these
   insertion targets.  The sub-model must allocate enough space for
   each of the types that will accept default insertions, and the
   leading set of matching sub-model variables are updated (i.e., the
   sub-model may allocate more than needed and the trailing set will
   be unmodified).

These different variable mapping possibilities may be used in any
combination by employing empty strings (\c '') for particular omitted
mappings (the number of strings in user-supplied primary and secondary
variable mapping specifications must equal the total number of active
top-level variables, including both continuous and discrete types).
The ordering of the active variables is the same as shown in
dakota.input.summary and as presented in \ref VarCommands.

If inactive variables are present at the outer level, then the default
type 3 mapping is used for these variables; that is, outer loop
inactive variables are inserted into inner loop variables (active or
inactive) based on matching of variable types, top-level bounds and
labels are also propagated, the inner loop must allocate sufficient
space to receive the outer loop values, and the leading subset within
this inner loop allocation is updated.  This capability is important
for allowing nesting beyond two levels, since an active variable at the
outer-most loop may become inactive at the next lower level, but still
needs to be further propagated down to lower levels in the recursion.

For the response mappings, the primary and secondary specifications
provide real-valued multipliers to be applied to sub-iterator response
results so that the responses from the inner loop can be mapped into a
new set of responses at the outer loop.  For example, if the nested
model is being employed within a mixed aleatory-epistemic uncertainty
quantification, then aleatory statistics from the inner loop (such as
moments of the response) are mapped to the outer level, where minima
and maxima of these aleatory statistics are computed as functions of
the epistemic parameters. The response mapping defines a matrix which
scales the values from the inner loop and determines their position in
the outer loop response vector.  Each row of the mapping corresponds
to one outer loop response, where each column of the mapping
corresponds to a value from the inner loop.  Depending on the number
of responses and the particular attributes calculated on the inner
loop, there will be a vector of inner loop response values that need
to be accounted for in the mapping.  This vector of inner loop
response results is defined as follows for different sub-iterator types:

- optimization: the final objective function(s) and nonlinear constraints
- nonlinear least squares: the final least squares terms and nonlinear 
  constraints
- aleatory uncertainty quantification (UQ): for each response function, a mean 
  statistic, a standard deviation statistic, and all 
  probability/reliability/generalized reliability/response level results 
  for any user-specified \c response_levels, \c probability_levels, 
  \c reliability_levels, and/or \c gen_reliability_levels, in that order.
- epistemic and mixed aleatory/epistemic UQ using interval estimation
  methods: lower and upper interval bounds for each response function.
- epistemic and mixed aleatory/epistemic UQ using evidence methods: for 
  each response function, lower and upper interval bounds (belief and
  plausibility) for all probability/reliability/generalized
  reliability/response level results computed from any user-specified \c
  response_levels, \c probability_levels, \c reliability_levels, and/or 
  \c gen_reliability_levels, in that order.
- parameter studies and design of experiments: for optimization and
  least squares response data sets, the best solution found (lowest
  constraint violation if infeasible, lowest composite objective function
  if feasible). For generic response data sets, a best solution metric is 
  not defined, so the sub-iterator response vector is empty in this case.

The primary values map sub-iterator response results into top-level
objective functions, least squares terms, or generic response
functions, depending on the declared top-level response set.  The
secondary values map sub-iterator response results into top-level
nonlinear inequality and equality constraints.  Refer to \ref
NestedModel::response_mapping "NestedModel::response_mapping()" for
additional details.  

An example of variable and response mappings is provided below:
\verbatim
primary_variable_mapping   = ''  ''  'X'     'Y'
secondary_variable_mapping = ''  ''  'mean'  'mean'
primary_response_mapping   = 1. 0. 0. 0. 0. 0. 0. 0. 0.
secondary_response_mapping = 0. 0. 0. 1. 3. 0. 0. 0. 0.
                             0. 0. 0. 0. 0. 0. 1. 3. 0.
\endverbatim

The variable mappings correspond to 4 top-level variables, the first
two of which employ the default mappings from active top-level
variables to sub-model variables of the same type (option 3 above) and
the latter two of which are inserted into the mean distribution
parameters of sub-model variables \c 'X' and \c 'Y' (option 1 above).
The response mappings define a 3 by 9 matrix corresponding to 9 inner
loop response attributes and 3 outer loop response functions (one
primary response function and 2 secondary functions, such as one
objective and two constraints).  Each row of the response mapping is a
vector which is multiplied (i.e, with a dot-product) against the 9
sub-iterator values to determine the outer loop function.  Consider a
UQ example with 3 response functions, each providing a mean, a
standard deviation, and one level mapping (if no level mappings are
specified, the responses would only have a mean and standard
deviation).  The primary response mapping can be seen to extract the
first value from the inner loop, which would correspond to the mean of
the first response function.  This mapped sub-iterator response
becomes a single objective function, least squares term, or generic
response function at the outer level, as dictated by the top-level
response specification.  The secondary response mapping maps the
fourth sub-iterator response function plus 3 times the fifth
sub-iterator response function (mean plus 3 standard deviations) into
one top-level nonlinear constraint and the seventh sub-iterator
response function plus 3 times the eighth sub-iterator response
function (mean plus 3 standard deviations) into another top-level
nonlinear constraint, where these top-level nonlinear constraints may
be inequality or equality, as dictated by the top-level response
specification.  Note that a common case is for each sub-iterator
response to be mapped to a unique outer loop response (for example, in
the nested UQ case where one wants to determine an interval on each
inner loop statistic).  In these simple cases, the response mapping
would define an identity matrix.  <!-- That is, the primary response
mapping will have N rows and N columns corresponding to the N
sub-iterator response values, and the mapping matrix will have a value
of one along the diagonal and zeros elsewhere. -->

Table \ref T6d11 "6.11" provides the specification detail for the model
independent controls involving nested model mappings.

\anchor T6d11
<table>
<caption align = "top">
\htmlonly
Table 6.11
\endhtmlonly
Specification detail for the model independent controls: nested model mappings
</caption>
<tr>
<td><b>Description</b>
<td><b>Keyword</b>
<td><b>Associated Data</b>
<td><b>Status</b>
<td><b>Default</b>
<tr>
<td>Primary variable mappings for nested models
<td>\c primary_variable_mapping
<td>list of strings
<td>Optional
<td>default variable insertions based on variable type
<tr>
<td>Secondary variable mappings for nested models
<td>\c secondary_variable_mapping
<td>list of strings
<td>Optional
<td>primary mappings into sub-model variables are value-based
<tr>
<td>Primary response mappings for nested models
<td>\c primary_response_mapping
<td>list of reals
<td>Optional
<td>no sub-iterator contribution to primary functions
<tr>
<td>Secondary response mappings for nested models
<td>\c secondary_response_mapping
<td>list of reals
<td>Optional
<td>no sub-iterator contribution to secondary functions
</table>

\htmlonly
<hr>
<br><b><a href="MethodCommands.html#MethodCommands">Previous chapter</a></b>
<br>
<br><b><a href="VarCommands.html#VarCommands">Next chapter</a></b>
\endhtmlonly

*/

} // namespace Dakota
