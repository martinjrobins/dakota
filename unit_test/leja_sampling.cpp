#include "dakota_global_defs.hpp"
#include "DakotaResponse.hpp"
#include "DistributionParams.hpp"
#include "BasisPolynomial.hpp"
//#include "SharedPolyApproxData.hpp"
#include "nested_sampling.hpp"
#include "SharedOrthogPolyApproxData.hpp"
// Boost.Test
#include <boost/test/minimal.hpp>

//#include <boost/assign/std/vector.hpp>
#include <boost/foreach.hpp>

#include <cassert>
#include <iostream>


namespace Dakota {
namespace TestLejaSampling {

/** \brief Create an AleatoryDistParams object such that all variables are 
 * uniform in [l_bnd, u_bnd]
 */
  Pecos::AleatoryDistParams 
  initialize_homgeneous_uniform_aleatory_dist_params(int num_vars, Real l_bnd, 
						     Real u_bnd ){

  RealVector nuv_means;
  RealVector nuv_std_devs;     RealVector nuv_l_bnds;
  RealVector nuv_u_bnds;       RealVector lnuv_means;
  RealVector lnuv_std_devs;    RealVector lnuv_lambdas;
  RealVector lnuv_zetas;       RealVector lnuv_err_facts;
  RealVector lnuv_l_bnds;      RealVector lnuv_u_bnds;
  RealVector uuv_l_bnds;       RealVector uuv_u_bnds;
  RealVector luuv_l_bnds;      RealVector luuv_u_bnds;
  RealVector tuv_modes;        RealVector tuv_l_bnds;
  RealVector tuv_u_bnds;       RealVector euv_betas;
  RealVector beuv_alphas;      RealVector beuv_betas;
  RealVector beuv_l_bnds;      RealVector beuv_u_bnds;
  RealVector gauv_alphas;      RealVector gauv_betas;
  RealVector guuv_alphas;      RealVector guuv_betas;
  RealVector fuv_alphas;       RealVector fuv_betas;
  RealVector wuv_alphas;       RealVector wuv_betas;
  RealRealMapArray hbuv_prs;   RealVector puv_lambdas;
  RealVector biuv_p_per_tr;    IntVector biuv_num_trials; 
  RealVector nbuv_p_per_tr;    IntVector nbuv_num_trials; 
  RealVector geuv_p_per_tr;    IntVector hguv_tot_pop;
  IntVector hguv_sel_pop;      IntVector hguv_num_drawn;
  IntRealMapArray hpuiv_prs;   StringRealMapArray hpusv_prs;
  RealRealMapArray hpurv_prs;  RealSymMatrix uv_corr;

  uuv_l_bnds.sizeUninitialized( num_vars );
  uuv_l_bnds = l_bnd;
  uuv_u_bnds.sizeUninitialized( num_vars );
  uuv_u_bnds = u_bnd;

  Pecos::AleatoryDistParams adp(nuv_means,
				nuv_std_devs,     nuv_l_bnds,
				nuv_u_bnds,       lnuv_means,
				lnuv_std_devs,    lnuv_lambdas,
				lnuv_zetas,       lnuv_err_facts,
				lnuv_l_bnds,      lnuv_u_bnds,
				uuv_l_bnds,       uuv_u_bnds,
				luuv_l_bnds,      luuv_u_bnds,
				tuv_modes,        tuv_l_bnds,
				tuv_u_bnds,       euv_betas,
				beuv_alphas,      beuv_betas,
				beuv_l_bnds,      beuv_u_bnds,
				gauv_alphas,      gauv_betas,
				guuv_alphas,      guuv_betas,
				fuv_alphas,       fuv_betas,
				wuv_alphas,       wuv_betas,
				hbuv_prs,         puv_lambdas,
				biuv_p_per_tr,    biuv_num_trials, 
				nbuv_p_per_tr,    nbuv_num_trials, 
				geuv_p_per_tr,    hguv_tot_pop,
				hguv_sel_pop,     hguv_num_drawn,
				hpuiv_prs,        hpusv_prs,
				hpurv_prs,  uv_corr);
  return adp;
}

void test_uniform_leja_sequence(){
  int num_vars = 2;
  int num_initial_samples = 10;
  int num_new_samples = 20;
  int num_candidate_samples = 10000;
  int seed = 1;

  // Currently Leja Sampler assumes that the samples are in U space
  // that is the native space of the polynomial. For Legendre polynomials
  // the parameter range is [-1,1]
  Pecos::AleatoryDistParams adp = 
    initialize_homgeneous_uniform_aleatory_dist_params(num_vars,-1,1);
  ShortArray u_types(num_vars,Pecos::STD_UNIFORM);

  // Build polynomial basis using default basis configuration options
  Pecos::BasisConfigOptions bc_options;
  std::vector<Pecos::BasisPolynomial> poly_basis;
  Pecos::SharedOrthogPolyApproxData::construct_basis(u_types, adp, bc_options, 
						     poly_basis);

  // Initialize sampling object
  LejaSampler sampler;
  sampler.set_precondition(true);
  sampler.set_polynomial_basis(poly_basis);
  
  // Get candidate samples. Replace this with samples generated by Dakota,
  // which are sampled from the probability measure of each aleatory variable
  RealMatrix candidate_samples;
  sampler.get_candidate_samples( num_vars, num_candidate_samples, seed,
				 candidate_samples );

  // Generate initial samples
  RealMatrix initial_samples, empty_matrix;
  // The test only works if we use the same degree at every step.
  int num_total_samples = num_initial_samples + num_new_samples;
  sampler.set_total_degree_basis_from_num_samples(num_vars, num_total_samples);
  // First time sampler is called there are no samples we wish to reuse
  // so pass in empty matrix
  sampler.Sampler::enrich_samples( num_vars, empty_matrix, num_initial_samples,
				   candidate_samples, initial_samples );

  // Enrich initial_samples
  RealMatrix enriched_samples;
  sampler.set_total_degree_basis_from_num_samples(num_vars, num_total_samples);
  sampler.Sampler::enrich_samples( num_vars, initial_samples, num_new_samples,
				   candidate_samples, enriched_samples );

  RealMatrix enriched_samples_subset( Teuchos::Copy, enriched_samples, num_vars,
				      num_initial_samples );
  enriched_samples_subset -= initial_samples;
  BOOST_CHECK( enriched_samples_subset.normInf() < 
	       10.*std::numeric_limits<double>::epsilon() );

  // Run sampler and generate all points in one go
  RealMatrix combined_samples;
  sampler.set_total_degree_basis_from_num_samples(num_vars, num_total_samples);
  sampler.Sampler::enrich_samples( num_vars, empty_matrix, num_total_samples,
				   candidate_samples, combined_samples );

  // Check samples obtained by running algorithm once are the same
  // as those obtained running the algorithm in steps.
  combined_samples -= enriched_samples;
  BOOST_CHECK( combined_samples.normInf() < 
	       10.*std::numeric_limits<double>::epsilon() );
  
}

} // end namespace TestFieldCovariance
} // end namespace Dakota

// NOTE: Boost.Test framework provides the main progran driver

//____________________________________________________________________________//

int test_main( int argc, char* argv[] )      // note the name!
{
  using namespace Dakota::TestLejaSampling;

  test_uniform_leja_sequence();

  int run_result = 0;
  BOOST_CHECK( run_result == 0 || run_result == boost::exit_success );

  return boost::exit_success;
}
